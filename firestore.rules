rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(field) {
      return isSignedIn() && field == request.auth.uid;
    }

    // Diagnostic Reports - Write-only para todos (anônimo ok)
    // Apenas admin pode ler via Firebase Console
    match /diagnostic_reports/{reportId} {
      // Qualquer um pode criar um relatório
      allow create: if true;

      // Apenas o próprio usuário autenticado pode ler seu relatório
      // (ou ninguém, se quisermos 100% write-only)
      allow read: if false; // write-only puro

      // Validação do documento
      allow create: if request.resource.data.keys().hasAll([
        'timestamp', 'browser', 'os', 'system'
      ]) && request.resource.data.message is string
         && request.resource.data.message.size() < 1000; // max 1000 chars
    }

    // Protocolos públicos - Read-only para todos
    // Apenas admin pode escrever via Firebase Console
    match /protocols/{protocolId} {
      allow read: if true; // público
      allow write: if false; // apenas admin via console
    }

    // Track presets (audio voices)
    match /presets_audio/{presetId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update, delete: if isOwner(resource.data.createdBy);
    }

    // Session presets (multi-voice sessions)
    match /presets_sessions/{presetId} {
      allow read: if true;
      allow create: if isSignedIn();
      allow update, delete: if isOwner(resource.data.createdBy);
    }

    // Sessões de usuário (futuro) - requer autenticação
    match /sessions/{sessionId} {
      allow read, write: if request.auth != null
                         && request.auth.uid == resource.data.userId;
    }

    // Preferências de privacidade por usuário
    match /user_settings/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Eventos privados de uso - acessíveis apenas pelo próprio usuário
    match /usage_events/{eventId} {
      allow create: if request.auth != null
                     && request.auth.uid == request.resource.data.userId;
      allow read: if request.auth != null
                   && request.auth.uid == resource.data.userId;
    }

    // Feed público anonimizado - leitura aberta, escrita apenas autenticada
    match /usage_events_public/{eventId} {
      allow read: if true;
      allow create: if request.auth != null
                     && !(request.resource.data.keys().hasAny(['userId', 'userUid']));
      allow update, delete: if false;
    }

    // Ontology Explorer comments: shared among users
    // Documents in collection 'ontology_comments' have fields:
    // { targetType: 'node'|'edge', targetId: string, text: string, userId: string, createdAt: timestamp }
    match /ontology_comments/{commentId} {
      allow read: if true; // public readable
      allow create: if request.auth != null
                    && request.resource.data.userId == request.auth.uid
                    && request.resource.data.targetType in ['node', 'edge']
                    && request.resource.data.targetId is string
                    && request.resource.data.text is string
                    && request.resource.data.text.size() > 0
                    && request.resource.data.text.size() <= 2000
                    && request.resource.data.createdAt is timestamp;
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
      // Allow soft-delete only (toggle deleted->true) by owner
      allow update: if request.auth != null
                     && request.auth.uid == resource.data.userId
                     && request.resource.data.keys().hasOnly(['targetType','targetId','text','userId','createdAt','parentId','deleted'])
                     && request.resource.data.deleted == true
                     && resource.data.deleted != true;

      // Reactions subcollection: one doc per user with { type: 'like'|'dislike'|'heart'|'celebrate' }
      match /reactions/{userId} {
        allow read: if true;
        allow create, update, delete: if request.auth != null
                                       && request.auth.uid == userId
                                       && request.resource.data.keys().hasOnly(['type'])
                                       && request.resource.data.type in ['like','dislike','heart','celebrate'];
      }
    }

    // Meta collection to quickly detect commented targets and counts
    // Doc id = targetId; fields: { count: number }
    match /ontology_comments_meta/{targetId} {
      allow read: if true;
      allow create, update: if request.auth != null;
      allow delete: if request.auth != null; // cleaned up when count hits 0
    }

    // Bloquear tudo que não está explicitamente permitido
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
